import tempfile,stat,os

class MPIConfigError(Exception): pass
class WrongMPI(MPIConfigError): pass
class MPISerialMissing(MPIConfigError):
    """Raised when the mpiserial program is required, but is missing."""
class MPIAllRanksError(MPIConfigError):
    """Raised when the allranks=True keyword is sent to mpirun or mpirunner,
but the MPI program specification has more than one rank."""
class MPIMixed(MPIConfigError):
    """Thrown to indicate serial and parallel processes are being mixed in a single mpi_comm_world."""

class CMDFGen(object):
    """This class is used to generate command files for mpiserial, poe
    or mpirun.lsf.  Command files are files with one MPI rank per line
    containing a shell command to run for that rank.  Generally the
    input (lines) is generated by the to_arglist function in a
    subclass of produtil.mpiprog.MPIRanksBase.  See the
    produtil.mpi_impl.mpirun_lsf for an example of how to use this."""
    def __init__(self,base,lines,cmd_envar='SCR_CMDFILE',
                 model_envar=None,**kwargs):
        assert(base is not None)
        assert(isinstance(lines,list))
        assert(len(lines)>0)
        assert(isinstance(lines[0],basestring))
        assert(len(lines[0])>0)
        self.filename=kwargs.get(str(base),None)
        self.tmpprefix=kwargs.get('%s_suffix'%(base,),'%s.'%(base,))
        self.tmpsuffix=kwargs.get('%s_suffix'%(base,),'.cmdf')
        self.tmpdir=kwargs.get('%s_tmpdir'%(base,),'.')
        self.cmd_envar=cmd_envar
        self.model_envar=model_envar
        out='\n'.join(lines)
        if len(out)>0:
            out+='\n'
        self.cmdf_contents=out
    def _add_more_vars(self,envars,logger):
        """Adds additional environment variables to the envars dict,
        needed to configure the MPI implementation correctly.  This is
        used to set MP_PGMMODEL="MPMD" if the constructor receives
        model_envar="MP_PGMMODEL"."""
        if self.model_envar is not None:
            if logger is not None:
                logger.info('Set %s="MPMD"'%(self.model_envar,))
            envars[self.model_envar]='MPMD'
    def __call__(self,runner,logger=None):
        if self.filename is not None:
            with open(self.filename,'wt') as f:
                f.write(self.cmdf_contents)
            if logger is not None:
                logger.info('Write command file to %s'%(repr(filename),))
            kw={self.cmd_envar: self.filename}
            self._add_more_vars(kw,logger)
            if logger is not None:
                for k,v in kw.iteritems():
                    logger.info('Set %s=%s'%(k,repr(v)))
            return runner.env(**kw)
        else:
            with tempfile.NamedTemporaryFile(mode='wt',suffix=self.tmpsuffix,
                    prefix=self.tmpprefix,dir=self.tmpdir,delete=False) as t:
                if logger is not None:
                    logger.info('Write command file to %s'%(repr(t.name),))
                t.write(self.cmdf_contents)
                # Make the file read-only and readable for everyone:
                os.fchmod(t.fileno(),stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)
                kw={self.cmd_envar: t.name}
                self._add_more_vars(kw,logger)
                if logger is not None:
                    for k,v in kw.iteritems():
                        logger.info('Set %s=%s'%(k,repr(v)))
                runner.env(**kw)
            return runner
